/*
  dfs的记忆化搜索

  如果是问存不存在的，那么可以用memo缓存各个节点的状态，意思是 
    1.当前节点走不到底：走过了 直接返回。
    2.当前节点能走到底：也别走了 已经找到了，你的 dfs 不用尝试别的方案了 直接返回吧
  这种题 dfs 返回的结果是 true 或者 false


  如果需要输出各个结果，那memo需要记住各节点对应了哪些结果 , 
    也就是说 memo[i] 记住一个数组 [x, y, z] 表示包含当前节点后续所有符合条件的值的集合，
    比如第一个能满足的值已经输出了，后续第二个能满足的值在走到 i 的时候 能直接拼接上已经走过的成功的值集合 memo[i]
  这种题 dfs 返回的结果是 数组 []

  dfs 过程中 维护一个数组 res = []，上一步的递依赖下一步的res，如果没走通的情况下 dfs 返回 res 是个长度为 0 的空数组，归过程中的拼接 for 不会取到有用的值
  结束条件是：
    1.memo[i] 有集合，走过了，后面不用继续走了，拿memo[i]去前面拼接吧
    2.指针越界，返回 [[]] 表示走通了，拿去前面拼接吧
*/